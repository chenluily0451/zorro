import { Component, Input, Output, ViewEncapsulation, ViewChild, EventEmitter, forwardRef, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Observable } from 'rxjs/Observable';
import { NzSliderService } from './nz-slider.service';
var SliderHandle = (function () {
    function SliderHandle() {
    }
    return SliderHandle;
}());
export { SliderHandle };
var NzSliderComponent = (function () {
    // |--------------------------------------------------------------------------------------------
    // | Lifecycle hooks
    // |--------------------------------------------------------------------------------------------
    function NzSliderComponent(utils) {
        this.utils = utils;
        // Debugging
        this.nzDebugId = null; // set this id will print debug informations to console
        // Dynamic property settings
        this.nzDisabled = false;
        // Static configurations (properties that can only specify once)
        this.nzStep = 1;
        this.nzMarks = null;
        this.nzDots = false;
        this.nzMin = 0;
        this.nzMax = 100;
        this.nzIncluded = true;
        this.nzDefaultValue = null;
        this.nzOnAfterChange = new EventEmitter();
        // Inside properties
        this._range = false;
        this._vertical = false;
        this.value = null; // CORE value state
        this.cacheSliderStart = null;
        this.cacheSliderLength = null;
        this.prefixCls = 'ant-slider';
        this.activeValueIndex = null; // Current activated handle's index ONLY for range=true
        this.track = { offset: null, length: null }; // Track's offset and length
        this.bounds = { lower: null, upper: null }; // now for nz-slider-step
        this.isDragging = false; // Current dragging state
    }
    Object.defineProperty(NzSliderComponent.prototype, "nzVertical", {
        get: function () {
            return this._vertical;
        },
        set: function (value) {
            if (value === '') {
                this._vertical = true;
            }
            else {
                this._vertical = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NzSliderComponent.prototype, "nzRange", {
        get: function () {
            return this._range;
        },
        set: function (value) {
            if (value === '') {
                this._range = true;
            }
            else {
                this._range = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    // |--------------------------------------------------------------------------------------------
    // | value accessors & ngModel accessors
    // |--------------------------------------------------------------------------------------------
    NzSliderComponent.prototype.setValue = function (val, isWriteValue) {
        if (isWriteValue === void 0) { isWriteValue = false; }
        if (isWriteValue) {
            this.value = this.formatValue(val);
            this.log("[ngModel:setValue/writeValue]Update track & handles");
            this.updateTrackAndHandles();
            if (!this.isValueEqual(this.value, val)) {
                this.log("[ngModel:setValue/writeValue]onValueChange", val);
                if (this.onValueChange) {
                    this.onValueChange(this.value);
                }
            }
        }
        else {
            if (!this.isValueEqual(this.value, val)) {
                this.value = val;
                this.log("[Normal:setValue]Update track & handles");
                this.updateTrackAndHandles();
                this.log("[Normal:setValue]onValueChange", val);
                if (this.onValueChange) {
                    this.onValueChange(this.value);
                }
            }
        }
    };
    NzSliderComponent.prototype.getValue = function (cloneAndSort) {
        if (cloneAndSort === void 0) { cloneAndSort = false; }
        if (cloneAndSort && this.nzRange) {
            return this.utils.cloneArray(this.value).sort(function (a, b) { return a - b; });
        }
        return this.value;
    };
    // clone & sort current value and convert them to offsets, then return the new one
    NzSliderComponent.prototype.getValueToOffset = function (value) {
        var _this = this;
        if (typeof value === 'undefined') {
            value = this.getValue(true);
        }
        return this.nzRange ?
            value.map(function (val) { return _this.valueToOffset(val); }) :
            this.valueToOffset(value);
    };
    NzSliderComponent.prototype.writeValue = function (val) {
        if (typeof this.onValueChange !== 'function') {
            return;
        } // ignore the first initial call
        this.log("[ngModel/writeValue]current writing value = ", val);
        this.setValue(val, true);
    };
    NzSliderComponent.prototype.registerOnChange = function (fn) {
        this.onValueChange = fn;
    };
    NzSliderComponent.prototype.registerOnTouched = function (fn) {
    };
    // initialize event binding, class init, etc. (called only once)
    NzSliderComponent.prototype.ngOnInit = function () {
        // initial checking
        this.checkValidValue(this.nzDefaultValue); // check nzDefaultValue
        // default handles
        this.handles = this._generateHandles(this.nzRange ? 2 : 1);
        // initialize
        this.sliderDOM = this.slider.nativeElement;
        if (this.getValue() === null) {
            this.setValue(this.formatValue(null));
        } // init with default value
        this.marksArray = this.nzMarks === null ? null : this.toMarksArray(this.nzMarks);
        // event bindings
        this.createDrag();
        // initialize drag's disabled status
        this.toggleDragDisabled(this.nzDisabled);
        // the first time to init classes
        this.setClassMap();
    };
    NzSliderComponent.prototype.ngOnChanges = function (changes) {
        var nzDisabled = changes.nzDisabled;
        if (nzDisabled && !nzDisabled.firstChange) {
            this.toggleDragDisabled(nzDisabled.currentValue);
            this.setClassMap();
        }
    };
    NzSliderComponent.prototype.ngOnDestroy = function () {
        this.unsubscribeDrag();
    };
    // |--------------------------------------------------------------------------------------------
    // | Basic flow functions
    // |--------------------------------------------------------------------------------------------
    NzSliderComponent.prototype.setClassMap = function () {
        var _a = this, prefixCls = _a.prefixCls, nzDisabled = _a.nzDisabled, nzVertical = _a.nzVertical, marksArray = _a.marksArray;
        this.classMap = (_b = {},
            _b[prefixCls] = true,
            _b[prefixCls + "-disabled"] = nzDisabled,
            _b[prefixCls + "-vertical"] = nzVertical,
            _b[prefixCls + "-with-marks"] = marksArray ? marksArray.length : 0,
            _b);
        var _b;
    };
    // find the cloest value to be activated (only for range = true)
    NzSliderComponent.prototype.setActiveValueIndex = function (pointerValue) {
        if (this.nzRange) {
            var minimal_1 = null, gap_1, activeIndex_1;
            this.getValue().forEach(function (val, index) {
                gap_1 = Math.abs(pointerValue - val);
                if (minimal_1 === null || gap_1 < minimal_1) {
                    minimal_1 = gap_1;
                    activeIndex_1 = index;
                }
            });
            this.activeValueIndex = activeIndex_1;
        }
    };
    NzSliderComponent.prototype.setActiveValue = function (pointerValue) {
        if (this.nzRange) {
            var newValue = this.utils.cloneArray(this.value);
            newValue[this.activeValueIndex] = pointerValue;
            this.setValue(newValue);
        }
        else {
            this.setValue(pointerValue);
        }
    };
    NzSliderComponent.prototype.updateTrackAndHandles = function () {
        var _this = this;
        var value = this.getValue();
        var offset = this.getValueToOffset(value);
        var valueSorted = this.getValue(true);
        var offsetSorted = this.getValueToOffset(valueSorted);
        var boundParts = this.nzRange ? valueSorted : [0, valueSorted];
        var trackParts = this.nzRange ? [offsetSorted[0], offsetSorted[1] - offsetSorted[0]] : [0, offsetSorted];
        this.handles.forEach(function (handle, index) {
            handle.offset = _this.nzRange ? offset[index] : offset;
            handle.value = _this.nzRange ? value[index] : value;
        });
        this.bounds.lower = boundParts[0], this.bounds.upper = boundParts[1];
        this.track.offset = trackParts[0], this.track.length = trackParts[1];
    };
    NzSliderComponent.prototype.toMarksArray = function (marks) {
        var _a = this, nzMin = _a.nzMin, nzMax = _a.nzMax;
        var marksArray = [];
        for (var key in marks) {
            var mark = marks[key];
            var val = typeof key === 'number' ? key : parseFloat(key);
            if (val < nzMin || val > nzMax) {
                continue;
            }
            marksArray.push({ value: val, offset: this.valueToOffset(val), config: mark });
        }
        return marksArray;
    };
    // |--------------------------------------------------------------------------------------------
    // | Event listeners & bindings
    // |--------------------------------------------------------------------------------------------
    NzSliderComponent.prototype.onDragStart = function (value) {
        this.log('[onDragStart]dragging value = ', value);
        this.toggleDragMoving(true);
        // cache DOM layout/reflow operations
        this.cacheSliderProperty();
        // trigger drag start
        this.setActiveValueIndex(value);
        this.setActiveValue(value);
        // Tooltip visibility of handles
        this._showHandleTooltip(this.nzRange ? this.activeValueIndex : 0);
    };
    NzSliderComponent.prototype.onDragMove = function (value) {
        this.log('[onDragMove]dragging value = ', value);
        // trigger drag moving
        this.setActiveValue(value);
    };
    NzSliderComponent.prototype.onDragEnd = function () {
        this.log('[onDragEnd]');
        this.toggleDragMoving(false);
        this.nzOnAfterChange.emit(this.getValue(true));
        // remove cache DOM layout/reflow operations
        this.cacheSliderProperty(true);
        // Hide all tooltip
        this._hideAllHandleTooltip();
    };
    NzSliderComponent.prototype.createDrag = function () {
        var _this = this;
        var sliderDOM = this.sliderDOM, orientField = this.nzVertical ? 'pageY' : 'pageX', mouse = {
            start: 'mousedown', move: 'mousemove', end: 'mouseup',
            pluckKey: [orientField]
        }, touch = {
            start: 'touchstart', move: 'touchmove', end: 'touchend',
            pluckKey: ['touches', '0', orientField],
            filter: function (e) { return !_this.utils.isNotTouchEvent(e); }
        };
        // make observables
        [mouse, touch].forEach(function (source) {
            var start = source.start, move = source.move, end = source.end, pluckKey = source.pluckKey, _a = source.filter, filter = _a === void 0 ? function () { return true; } : _a;
            // start
            source.startPlucked$ = (_b = Observable
                .fromEvent(sliderDOM, start)
                .filter(filter)
                .do(_this.utils.pauseEvent)).pluck.apply(_b, pluckKey).map(function (position) { return _this.findClosestValue(position); });
            // end
            source.end$ = Observable.fromEvent(document, end);
            // resolve move
            source.moveResolved$ = (_c = Observable
                .fromEvent(document, move)
                .filter(filter)
                .do(_this.utils.pauseEvent)).pluck.apply(_c, pluckKey).distinctUntilChanged()
                .map(function (position) { return _this.findClosestValue(position); })
                .distinctUntilChanged()
                .takeUntil(source.end$);
            var _b, _c;
            // merge to become moving
            // source.move$ = source.startPlucked$.mergeMapTo(source.moveResolved$);
        });
        // merge mouse and touch observables
        this.dragstart$ = Observable.merge(mouse.startPlucked$, touch.startPlucked$);
        // this.dragmove$ = Observable.merge(mouse.move$, touch.move$);
        this.dragmove$ = Observable.merge(mouse.moveResolved$, touch.moveResolved$);
        this.dragend$ = Observable.merge(mouse.end$, touch.end$);
    };
    NzSliderComponent.prototype.subscribeDrag = function (periods) {
        if (periods === void 0) { periods = ['start', 'move', 'end']; }
        this.log('[subscribeDrag]this.dragstart$ = ', this.dragstart$);
        if (periods.indexOf('start') !== -1 && this.dragstart$ && !this.dragstart_) {
            this.dragstart_ = this.dragstart$.subscribe(this.onDragStart.bind(this));
        }
        if (periods.indexOf('move') !== -1 && this.dragmove$ && !this.dragmove_) {
            this.dragmove_ = this.dragmove$.subscribe(this.onDragMove.bind(this));
        }
        if (periods.indexOf('end') !== -1 && this.dragend$ && !this.dragend_) {
            this.dragend_ = this.dragend$.subscribe(this.onDragEnd.bind(this));
        }
    };
    NzSliderComponent.prototype.unsubscribeDrag = function (periods) {
        if (periods === void 0) { periods = ['start', 'move', 'end']; }
        this.log('[unsubscribeDrag]this.dragstart_ = ', this.dragstart_);
        if (periods.indexOf('start') !== -1 && this.dragstart_) {
            this.dragstart_.unsubscribe();
            this.dragstart_ = null;
        }
        if (periods.indexOf('move') !== -1 && this.dragmove_) {
            this.dragmove_.unsubscribe();
            this.dragmove_ = null;
        }
        if (periods.indexOf('end') !== -1 && this.dragend_) {
            this.dragend_.unsubscribe();
            this.dragend_ = null;
        }
    };
    NzSliderComponent.prototype.toggleDragMoving = function (movable) {
        var periods = ['move', 'end'];
        if (movable) {
            this.isDragging = true;
            this.subscribeDrag(periods);
        }
        else {
            this.isDragging = false;
            this.unsubscribeDrag(periods);
        }
    };
    NzSliderComponent.prototype.toggleDragDisabled = function (disabled) {
        if (disabled) {
            this.unsubscribeDrag();
        }
        else {
            this.subscribeDrag(['start']);
        }
    };
    // |--------------------------------------------------------------------------------------------
    // | Util functions (tools)
    // |--------------------------------------------------------------------------------------------
    // find the closest value depend on pointer's position
    NzSliderComponent.prototype.findClosestValue = function (position) {
        var _a = this, nzVertical = _a.nzVertical, nzStep = _a.nzStep, nzMin = _a.nzMin, nzMax = _a.nzMax, nzMarks = _a.nzMarks, nzDots = _a.nzDots, utils = _a.utils, sliderStart = this.getSliderStartPosition(), sliderLength = this.getSliderLength();
        var ratio = utils.correctNumLimit((position - sliderStart) / sliderLength, 0, 1), val = (nzMax - nzMin) * (nzVertical ? 1 - ratio : ratio) + nzMin, points = (nzMarks === null ? [] : Object.keys(nzMarks).map(parseFloat));
        // push closest step
        if (nzStep !== null && !nzDots) {
            var closest_1 = Math.round(val / nzStep) * nzStep;
            points.push(closest_1);
        }
        // calculate gaps
        var gaps = points.map(function (point) { return Math.abs(val - point); });
        var closest = points[gaps.indexOf(Math.min.apply(Math, gaps))];
        // return the fixed
        return nzStep === null ? closest :
            parseFloat(closest.toFixed(utils.getPrecision(nzStep)));
    };
    NzSliderComponent.prototype.valueToOffset = function (value) {
        return this.utils.valueToOffset(this.nzMin, this.nzMax, value);
    };
    NzSliderComponent.prototype.getSliderStartPosition = function () {
        if (this.cacheSliderStart !== null) {
            return this.cacheSliderStart;
        }
        var offset = this.utils.getElementOffset(this.sliderDOM);
        return this.nzVertical ? offset.top : offset.left;
    };
    NzSliderComponent.prototype.getSliderLength = function () {
        if (this.cacheSliderLength !== null) {
            return this.cacheSliderLength;
        }
        var sliderDOM = this.sliderDOM;
        return this.nzVertical ?
            sliderDOM.clientHeight : sliderDOM.clientWidth;
    };
    // cache DOM layout/reflow operations for performance (may not necessary?)
    NzSliderComponent.prototype.cacheSliderProperty = function (remove) {
        if (remove === void 0) { remove = false; }
        this.cacheSliderStart = remove ? null : this.getSliderStartPosition();
        this.cacheSliderLength = remove ? null : this.getSliderLength();
    };
    NzSliderComponent.prototype.formatValue = function (value) {
        var _this = this;
        if (!this.checkValidValue(value)) {
            value = this.nzDefaultValue === null ?
                (this.nzRange ? [this.nzMin, this.nzMax] : this.nzMin) : this.nzDefaultValue;
        }
        else {
            value = this.nzRange ?
                value.map(function (val) { return _this.utils.correctNumLimit(val, _this.nzMin, _this.nzMax); }) :
                this.utils.correctNumLimit(value, this.nzMin, this.nzMax);
        }
        return value;
    };
    // check if value is valid and throw error if value-type/range not match
    NzSliderComponent.prototype.checkValidValue = function (value) {
        var range = this.nzRange;
        if (value === null || value === undefined) {
            return false;
        } // it's an invalid value, just return
        var isArray = Array.isArray(value);
        if (!isArray) {
            if (typeof value !== 'number') {
                value = parseFloat(value);
            }
            if (isNaN(value)) {
                return false;
            } // it's an invalid value, just return
        }
        if (isArray !== !!range) {
            throw new Error("The \"nzRange\" can't match the \"nzValue\"'s type, please check these properties: \"nzRange\", \"nzValue\", \"nzDefaultValue\".");
        }
        return true;
    };
    NzSliderComponent.prototype.isValueEqual = function (value, val) {
        if (typeof value !== typeof val) {
            return false;
        }
        if (Array.isArray(value)) {
            var len = value.length;
            for (var i = 0; i < len; i++) {
                if (value[i] !== val[i]) {
                    return false;
                }
            }
            return true;
        }
        else {
            return value === val;
        }
    };
    // print debug info
    NzSliderComponent.prototype.log = function () {
        var messages = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            messages[_i] = arguments[_i];
        }
        if (this.nzDebugId !== null) {
            var args = ["[nz-slider][#" + this.nzDebugId + "] "].concat(Array.prototype.slice.call(arguments));
            console.log.apply(null, args);
        }
    };
    // Show one handle's tooltip and hide others'
    NzSliderComponent.prototype._showHandleTooltip = function (handleIndex) {
        var _this = this;
        if (handleIndex === void 0) { handleIndex = 0; }
        this.handles.forEach(function (handle, index) {
            _this.handles[index].active = index === handleIndex;
        });
    };
    NzSliderComponent.prototype._hideAllHandleTooltip = function () {
        this.handles.forEach(function (handle) { return handle.active = false; });
    };
    NzSliderComponent.prototype._generateHandles = function (amount) {
        var handles = [];
        for (var i = 0; i < amount; i++) {
            handles.push({ offset: null, value: null, active: false });
        }
        return handles;
    };
    return NzSliderComponent;
}());
export { NzSliderComponent };
NzSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-slider',
                encapsulation: ViewEncapsulation.None,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(function () { return NzSliderComponent; }),
                        multi: true
                    }],
                template: "\n    <div #slider [ngClass]=\"classMap\">\n      <div class=\"ant-slider-rail\"></div>\n      <nz-slider-track\n        nzClassName=\"{{prefixCls}}-track\"\n        [nzVertical]=\"nzVertical\"\n        [nzIncluded]=\"nzIncluded\"\n        [nzOffset]=\"track.offset\"\n        [nzLength]=\"track.length\"\n      ></nz-slider-track>\n      <nz-slider-step *ngIf=\"marksArray\"\n        nzPrefixCls=\"{{prefixCls}}\"\n        [nzVertical]=\"nzVertical\"\n        [nzLowerBound]=\"bounds.lower\"\n        [nzUpperBound]=\"bounds.upper\"\n        [nzMarksArray]=\"marksArray\"\n        [nzIncluded]=\"nzIncluded\"\n      ></nz-slider-step>\n      <nz-slider-handle\n        *ngFor=\"let handle of handles;\"\n        nzClassName=\"{{prefixCls}}-handle\"\n        [nzVertical]=\"nzVertical\"\n        [nzOffset]=\"handle.offset\"\n        [nzValue]=\"handle.value\"\n        [nzActive]=\"handle.active\"\n        [nzTipFormatter]=\"nzTipFormatter\"\n      ></nz-slider-handle>\n      <nz-slider-marks *ngIf=\"marksArray\"\n        nzClassName=\"{{prefixCls}}-mark\"\n        [nzVertical]=\"nzVertical\"\n        [nzMin]=\"nzMin\"\n        [nzMax]=\"nzMax\"\n        [nzLowerBound]=\"bounds.lower\"\n        [nzUpperBound]=\"bounds.upper\"\n        [nzMarksArray]=\"marksArray\"\n        [nzIncluded]=\"nzIncluded\"\n      ></nz-slider-marks>\n    </div>\n  ",
                styles: [
                    "/* stylelint-disable at-rule-empty-line-before,at-rule-name-space-after,at-rule-no-unknown */\n/* stylelint-disable declaration-bang-space-before */\n/* stylelint-disable declaration-bang-space-before */\n.ant-slider {\n  position: relative;\n  margin: 10px 6px;\n  padding: 4px 0;\n  height: 12px;\n  cursor: pointer;\n}\n.ant-slider-vertical {\n  width: 12px;\n  height: 100%;\n  margin: 6px 10px;\n  padding: 0 4px;\n}\n.ant-slider-vertical .ant-slider-rail {\n  height: 100%;\n  width: 4px;\n}\n.ant-slider-vertical .ant-slider-track {\n  width: 4px;\n}\n.ant-slider-vertical .ant-slider-handle {\n  margin-left: -5px;\n  margin-bottom: -7px;\n}\n.ant-slider-vertical .ant-slider-mark {\n  top: 0;\n  left: 12px;\n  width: 18px;\n  height: 100%;\n}\n.ant-slider-vertical .ant-slider-mark-text {\n  left: 4px;\n  white-space: nowrap;\n}\n.ant-slider-vertical .ant-slider-step {\n  width: 4px;\n  height: 100%;\n}\n.ant-slider-vertical .ant-slider-dot {\n  top: auto;\n  left: 2px;\n  margin-bottom: -4px;\n}\n.ant-slider-with-marks {\n  margin-bottom: 28px;\n}\n.ant-slider-rail {\n  position: absolute;\n  width: 100%;\n  height: 4px;\n  border-radius: 2px;\n  background-color: #e9e9e9;\n  transition: background-color 0.3s ease;\n}\n.ant-slider-track {\n  position: absolute;\n  height: 4px;\n  border-radius: 4px;\n  background-color: #9fd2f6;\n  transition: background-color 0.3s ease;\n}\n.ant-slider-handle {\n  position: absolute;\n  margin-left: -7px;\n  margin-top: -5px;\n  width: 14px;\n  height: 14px;\n  cursor: pointer;\n  border-radius: 50%;\n  border: solid 2px #88c7f4;\n  background-color: #fff;\n  transition: border-color 0.3s ease, transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);\n}\n.ant-slider-handle:hover {\n  border-color: #49a9ee;\n  transform: scale(1.2);\n  transform-origin: center center;\n}\n.ant-slider-handle:active {\n  box-shadow: 0 0 0 2px rgba(16, 142, 233, 0.2);\n}\n.ant-slider:hover .ant-slider-rail {\n  background-color: #e1e1e1;\n}\n.ant-slider:hover .ant-slider-track {\n  background-color: #70bbf2;\n}\n.ant-slider:hover .ant-slider-handle {\n  border-color: #49a9ee;\n}\n.ant-slider-mark {\n  position: absolute;\n  top: 14px;\n  left: 0;\n  width: 100%;\n  font-size: 12px;\n}\n.ant-slider-mark-text {\n  position: absolute;\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n  cursor: pointer;\n  color: rgba(0, 0, 0, 0.43);\n}\n.ant-slider-mark-text-active {\n  color: rgba(0, 0, 0, 0.65);\n}\n.ant-slider-step {\n  position: absolute;\n  width: 100%;\n  height: 4px;\n  background: transparent;\n}\n.ant-slider-dot {\n  position: absolute;\n  top: -2px;\n  margin-left: -4px;\n  width: 8px;\n  height: 8px;\n  border: 2px solid #e9e9e9;\n  background-color: #fff;\n  cursor: pointer;\n  border-radius: 50%;\n  vertical-align: middle;\n}\n.ant-slider-dot:first-child {\n  margin-left: -4px;\n}\n.ant-slider-dot:last-child {\n  margin-left: -4px;\n}\n.ant-slider-dot-active {\n  border-color: #88c7f4;\n}\n.ant-slider-disabled {\n  cursor: not-allowed;\n}\n.ant-slider-disabled .ant-slider-track {\n  background-color: rgba(0, 0, 0, 0.25) !important;\n}\n.ant-slider-disabled .ant-slider-handle,\n.ant-slider-disabled .ant-slider-dot {\n  border-color: rgba(0, 0, 0, 0.25) !important;\n  background-color: #fff;\n  cursor: not-allowed;\n  box-shadow: none;\n}\n.ant-slider-disabled .ant-slider-mark-text,\n.ant-slider-disabled .ant-slider-dot {\n  cursor: not-allowed !important;\n}\n"
                ]
            },] },
];
/** @nocollapse */
NzSliderComponent.ctorParameters = function () { return [
    { type: NzSliderService, },
]; };
NzSliderComponent.propDecorators = {
    'nzDebugId': [{ type: Input },],
    'nzDisabled': [{ type: Input },],
    'nzStep': [{ type: Input },],
    'nzMarks': [{ type: Input },],
    'nzDots': [{ type: Input },],
    'nzMin': [{ type: Input },],
    'nzMax': [{ type: Input },],
    'nzIncluded': [{ type: Input },],
    'nzDefaultValue': [{ type: Input },],
    'nzTipFormatter': [{ type: Input },],
    'nzOnAfterChange': [{ type: Output },],
    'nzVertical': [{ type: Input },],
    'nzRange': [{ type: Input },],
    'slider': [{ type: ViewChild, args: ['slider',] },],
};
