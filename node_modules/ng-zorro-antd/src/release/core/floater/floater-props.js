var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { EventEmitter, TemplateRef } from '@angular/core';
import { ConnectionPositionPair } from '../overlay';
// Coerces a data-bound value (typically a string) to a boolean
function coerceBooleanProperty(value) {
    return value != null && "" + value !== 'false';
}
// Default set of positions for the overlay. Follows the behavior of a dropdown
var defaultPositionList = [
    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
];
// Options for floater (NOTE: don't like ConnectedOverlayDirective's @Input, normally, these options will be only used once at the initializing time)
var FloaterOptions = (function () {
    function FloaterOptions() {
        // ---------------------------------------------------------
        // | Configurations
        // ---------------------------------------------------------
        // Current position strategy
        this.positionStrategyType = 'connected';
        // Whether keep overlay existing except call detach() or destroy() manually
        this.persist = false;
        // ---------------------------------------------------------
        // | Emitters
        // ---------------------------------------------------------
        // Event emitted when the backdrop is clicked
        this.backdropClick = new EventEmitter();
        // Event emitted when the position has changed
        this.positionChange = new EventEmitter();
        // Event emitted when the overlay has been attached
        this.attach = new EventEmitter();
        // Event emitted when the overlay has been detached
        this.detach = new EventEmitter();
    }
    return FloaterOptions;
}());
export { FloaterOptions };
// Inner properties manager for floater
var FloaterProps = (function (_super) {
    __extends(FloaterProps, _super);
    // Options validator
    function FloaterProps(options) {
        var _this = _super.call(this) || this;
        _this._hasBackdrop = false;
        _this._emitterSubscriptions = [];
        // Validating
        _this._validateOptions(options);
        // Merge options
        Object.assign(_this, options);
        // Default values
        _this._initDefaultOptions();
        // Event listeners
        _this._initEventListeners();
        return _this;
    }
    Object.defineProperty(FloaterProps.prototype, "hasBackdrop", {
        get: function () {
            return this._hasBackdrop;
        },
        set: function (value) {
            this._hasBackdrop = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    FloaterProps.prototype._validateOptions = function (options) {
        if (!options.content) {
            throw new Error('[FloaterOptions] "content" is required.');
        }
        if (options.content instanceof TemplateRef && !options.viewContainerRef) {
            throw new Error('[FloaterOptions] "viewContainerRef" is required for "content" of TemplateRef.');
        }
        if (options.positionStrategyType === 'connected' && !options.positionStrategyOptions) {
            throw new Error('[FloaterOptions] "positionStrategyOptions" can\'t be empty when position strategy type is "connected".');
        }
    };
    FloaterProps.prototype._initDefaultOptions = function () {
        var strategyOptions = this.positionStrategyOptions;
        if (this.positionStrategyType === 'connected') {
            if (!strategyOptions.positions || !strategyOptions.positions.length) {
                strategyOptions.positions = defaultPositionList;
            }
        }
    };
    FloaterProps.prototype._initEventListeners = function () {
        var subscriptions = this._emitterSubscriptions;
        if (this.onBackdropClick) {
            subscriptions.push(this.backdropClick.subscribe(this.onBackdropClick));
        }
        if (this.onPositionChange) {
            subscriptions.push(this.positionChange.subscribe(this.onPositionChange));
        }
        if (this.onAttach) {
            subscriptions.push(this.attach.subscribe(this.onAttach));
        }
        if (this.onDetach) {
            subscriptions.push(this.detach.subscribe(this.onDetach));
        }
    };
    // ---------------------------------------------------------
    // | Public methods
    // ---------------------------------------------------------
    // Set current position strategy
    FloaterProps.prototype.setPositionStrategy = function (position) {
        this._position = position;
    };
    FloaterProps.prototype.getPositionStrategy = function () {
        return this._position;
    };
    // Destory all resources
    FloaterProps.prototype.destroy = function () {
        this._emitterSubscriptions.forEach(function (subscription) { return subscription.unsubscribe(); });
        this._emitterSubscriptions = null;
    };
    return FloaterProps;
}(FloaterOptions));
export { FloaterProps };
