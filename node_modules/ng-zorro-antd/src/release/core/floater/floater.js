import { TemplateRef, Renderer2 } from '@angular/core';
import { OverlayState, OverlayOrigin, ConnectedPositionStrategy } from '../overlay';
import { TemplatePortal, ComponentPortal, ESCAPE } from '@angular/cdk';
import { FloaterProps, } from './floater-props';
/**
 * Floater object to manage overlay (Enhanced verion of ConnectedOverlayDirective)
 * NOTE: don't like ConnectedOverlayDirective, Floater has no dependencies with directive (such as Component, Directive ...)
 *  but this will means that you should destroy it and incidental resources manually using destroy() method!
 */
var Floater = (function () {
    function Floater(_overlay, _renderer, options) {
        this._overlay = _overlay;
        this._renderer = _renderer;
        this._stateAttached = false; // State to prevent duplicated attaching/detaching
        this._stateDestroyed = false; // State to prevent duplicated destroying
        this._props = new FloaterProps(options);
        var _a = this._props, content = _a.content, viewContainerRef = _a.viewContainerRef, injector = _a.injector;
        if (content instanceof TemplateRef) {
            this._contentPortal = new TemplatePortal(content, viewContainerRef);
        }
        else if (typeof content === 'function') {
            this._contentPortal = new ComponentPortal(content, viewContainerRef, injector);
        }
        else {
            throw new Error('[Floater] Not support "content" type.');
        }
    }
    Object.defineProperty(Floater.prototype, "overlayRef", {
        // The associated overlay reference
        get: function () {
            return this._overlayRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Floater.prototype, "attachedResult", {
        // The attached component ref or template locals(haven't done yet)
        get: function () {
            return this._attachedResult;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Floater.prototype, "dir", {
        // The element's layout direction && The direction of the text in the overlay panel
        get: function () {
            return this._props.dir ? this._props.dir.value : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    // Get attached component's instance
    Floater.prototype.getComponentInstance = function () {
        if (!this._isCreatedByComponent()) {
            throw new Error("Cant't get ComponentRef when created without ComponentType (Should fill the \"content\" option with value of ComponentType)");
        }
        return this.attachedResult.instance;
    };
    Floater.prototype.attach = function () {
        if (!this._stateAttached) {
            this._stateAttached = true;
            this._attachOverlay();
        }
        return this;
    };
    Floater.prototype.detach = function () {
        if (this._stateAttached) {
            this._stateAttached = false;
            this._detachOverlay();
        }
        return this;
    };
    Floater.prototype.destroy = function () {
        if (!this._stateDestroyed) {
            this._stateDestroyed = true;
            this._destroyOverlay();
        }
        return this;
    };
    // Attaches the overlay and subscribes to backdrop clicks if backdrop exists
    Floater.prototype._attachOverlay = function () {
        // console.log('[Floater] Attach overlay');
        var _a = this._props, hasBackdrop = _a.hasBackdrop, backdropClick = _a.backdropClick, attach = _a.attach, persist = _a.persist;
        if (!this._overlayRef) {
            this._createOverlay();
        }
        var position = this._props.getPositionStrategy();
        if (position instanceof ConnectedPositionStrategy) {
            position.withDirection(this.dir);
        }
        this._overlayRef.getState().direction = this.dir;
        if (!persist) {
            this._initEscapeListener();
        }
        if (!this._overlayRef.hasAttached()) {
            this._attachedResult = this._overlayRef.attach(this._contentPortal);
            if (this._isCreatedByComponent()) {
                this._handleAttachedComponent(this._attachedResult);
            }
            if (attach) {
                attach.emit();
            }
        }
        if (hasBackdrop && backdropClick) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
                backdropClick.emit();
            });
        }
    };
    // Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
    Floater.prototype._detachOverlay = function () {
        // console.log('[Floater] Detach overlay');
        var detach = this._props.detach;
        if (this._overlayRef) {
            this._overlayRef.detach();
            if (detach) {
                detach.emit();
            }
        }
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
            this._backdropSubscription = null;
        }
        if (this._escapeListener) {
            this._escapeListener();
            this._escapeListener = null;
        }
    };
    // Destroys the overlay created by this directive
    Floater.prototype._destroyOverlay = function () {
        // console.log('[Floater] Destroy overlay');
        if (this._overlayRef) {
            this.overlayRef.dispose();
        }
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
        if (this._escapeListener) {
            this._escapeListener();
        }
        this._props.destroy();
    };
    // Creates an overlay
    Floater.prototype._createOverlay = function () {
        this._overlayRef = this._overlay.create(this._buildConfig(), this._props.paneClass);
    };
    // Builds the overlay config based on the directive's inputs
    Floater.prototype._buildConfig = function () {
        var overlayConfig = new OverlayState();
        var _a = this._props, width = _a.width, height = _a.height, minWidth = _a.minWidth, minHeight = _a.minHeight, hasBackdrop = _a.hasBackdrop, backdropClass = _a.backdropClass;
        if (width || width === 0) {
            overlayConfig.width = width;
        }
        if (height || height === 0) {
            overlayConfig.height = height;
        }
        if (minWidth || minWidth === 0) {
            overlayConfig.minWidth = minWidth;
        }
        if (minHeight || minHeight === 0) {
            overlayConfig.minHeight = minHeight;
        }
        overlayConfig.hasBackdrop = hasBackdrop;
        if (backdropClass) {
            overlayConfig.backdropClass = backdropClass;
        }
        var strategy = this._createPositionStrategy();
        if (strategy) {
            this._props.setPositionStrategy(strategy);
            overlayConfig.positionStrategy = strategy;
            // Use noop scroll strategy by default
            overlayConfig.scrollStrategy =
                this._props.scrollStrategy ? this._props.scrollStrategy : this._overlay.scrollStrategies.noop();
        }
        return overlayConfig;
    };
    // Returns the position strategy of the overlay to be set on the overlay config
    Floater.prototype._createPositionStrategy = function () {
        var _a = this._props, strategyType = _a.positionStrategyType, strategyOptions = _a.positionStrategyOptions;
        var strategy = null;
        if (strategyType === 'connected') {
            var _b = strategyOptions, positions = _b.positions, origin = _b.origin, offsetX = _b.offsetX, offsetY = _b.offsetY;
            var pos = positions[0];
            var originPoint = { originX: pos.originX, originY: pos.originY };
            var overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };
            var elementRef = origin instanceof OverlayOrigin ? origin.elementRef : origin;
            strategy = this._overlay.position()
                .connectedTo(elementRef, originPoint, overlayPoint)
                .withOffsetX(offsetX || 0)
                .withOffsetY(offsetY || 0);
            this._handlePositionChanges(strategy);
            if (!this._props.scrollStrategy) {
                this._props.scrollStrategy = this._overlay.scrollStrategies.reposition();
            }
        }
        else if (strategyType === 'free') {
            strategy = this._overlay.position().free();
        }
        return strategy;
    };
    // For ConnectedPositionStrategy ONLY
    Floater.prototype._handlePositionChanges = function (strategy) {
        var _a = this._props, strategyOptions = _a.positionStrategyOptions, positionChange = _a.positionChange;
        var positions = strategyOptions.positions;
        for (var i = 1; i < positions.length; i++) {
            strategy.withFallbackPosition({ originX: positions[i].originX, originY: positions[i].originY }, { overlayX: positions[i].overlayX, overlayY: positions[i].overlayY });
        }
        if (positionChange) {
            this._positionSubscription =
                strategy.onPositionChange.subscribe(function (pos) { return positionChange.emit(pos); });
        }
    };
    // Return if the floater is initialized by dynamic Component
    Floater.prototype._isCreatedByComponent = function () {
        return this._contentPortal instanceof ComponentPortal;
    };
    // Other works after creating component
    Floater.prototype._handleAttachedComponent = function (componentRef) {
        var instance = componentRef.instance, afterComponentCreated = this._props.afterComponentCreated;
        if (afterComponentCreated) {
            afterComponentCreated(instance);
        }
    };
    // Sets the event listener that closes the overlay when pressing Escape
    Floater.prototype._initEscapeListener = function () {
        var _this = this;
        var listener = function (event) {
            if (event.keyCode === ESCAPE) {
                _this._detachOverlay();
            }
        };
        if (this._renderer instanceof Renderer2) {
            this._escapeListener = this._renderer.listen('document', 'keydown', listener);
        }
        else if (this._renderer instanceof Document) {
            // console.log('[Floater/_initEscapeListener]use document', this._renderer);
            this._renderer.addEventListener('keydown', listener);
            this._escapeListener = function () {
                _this._renderer.removeEventListener('keydown', listener);
            };
        }
    };
    return Floater;
}());
export { Floater };
